searchState.loadedDescShard("competitive", 0, "github\nalgebra\nalgorithm\nMacro that returns a recursive function that …\ndata structures\ngraph structures and algorithms\nImplement <code>AssociatedValue</code>.\nPrint expressions with a separator.\nmathematical datas\nAutomatic memorization for recursive functions.\nMacro that define closure like macro. Unlike closure, this …\nsolve with Mo’s algorithm\nPrepare useful macros.\nDeclare random values using <code>RandomSpec</code>.\nReturn a random value using <code>RandomSpec</code>.\nscan and bind values with Scanner\nscan a value with Scanner\nstring algorithems\narg:\nbuild transducer\ntree algorithems\ncommutative group\ncommutative monoid\n$+,\\times$\n$+$\n$\\forall a,\\forall b,\\forall c \\in T, (a \\circ b) \\circ c …\n&amp;\n|\n^\n$\\forall a,\\forall b \\in T, a \\circ b = b \\circ a$\nFind majority(strict) of a sequence.\nretain the first element\nassociative binary operation and an identity element and …\n$\\forall a \\in T, a \\circ a = a$\nidempotent monoid\n$\\exists e \\in T, \\forall a \\in T, \\exists b,c \\in T, b …\nretain the last element\n$(a, b) \\circ (c, d) = \\lambda x. c \\times (a \\times x + …\n$(a, b) \\circ (c, d) = \\lambda x. c \\wedge (a \\wedge x …\nbinary operaion: $T \\circ T \\to T$\nbinary operation to select larger element\nbinary operation to select smaller element\nassociative binary operation and an identity element\n$\\times$\nassociative binary operation\ntype of operands: $T$\n$\\exists e \\in T, \\forall a \\in T, e \\circ a = a \\circ e = …\nadditive operaion: $+$\nadditive operaion: $+$\nmultiplicative right inversed operaion: $-$\nmultiplicative right inversed operaion: $-$\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nmultiplicative inverse: $-$\nmultiplicative inverse: $-$\n$a$ where $a \\circ x = e$\nmultiplicative operaion: $+$\nmultiplicative operaion: $+$\nadditive inverse: $-$\nadditive inverse: $-$\nmultiplicative identity: $1$\nmultiplicative identity: $1$\nbinary operaion: $\\circ$\nbinary exponentiation: $x^n = x\\circ\\ddots\\circ x$\nbinary exponentiation: $x^n = x\\circ\\ddots\\circ x$\nadditive right inversed operaion: $-$\nadditive right inversed operaion: $-$\nidentity element: $e$\nadditive identity: $0$\nadditive identity: $0$\nbinary search helper\n$P_0 =$ <code>init</code>, $P_{i+1} = next(P_i)$\nbinary search for slice\nBasis of xor operation.\nk-th add_line(a_k, b_k): a_k &gt;= a_{k+1}\n$\\min{0\\le i &lt; n | x^i=y}$\nReturn coordinate if element can be consisted by current …\nbinary search for monotone segment\nbuild rho path\nrho path that index of rho path\nThe smallest number of colors needed to color a graph.\nReturn coordinate if element can be consisted by current …\nReturns the first element that satisfies a predicate.\n$y = \\left\\lfloor\\frac{n}{x}\\right\\rfloor$\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget i-th value of rho path\nReturn true if inserted element cannot be consisted by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn between two elements if search is not end.\nCreate a empty space.\nReturns the first index that satisfies a predicate. if not …\nReturn (reduced basis, coordinate). Coordinate means if …\nReturns the last element that satisfies a predicate.\nReturns the last index+1 that satisfies a predicate. if …\nreturn: [(elem, length)]\nReturns the element that gives the minimum value from the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nempty sequence is included\nAccumlated data\n2-dimensional accumlated data\nDFA to accept Less/Greater than (or equal to) in …\nA map to control intervals that have same values.\nA set to control intervals.\nrank_i(select_i(k)) = k rank_i(select_i(k) + 1) = k + 1\nDFA to accept Less/Greater than (or equal to) in reversed …\nget k-th bit\nget k-th value\nReturn fold of [0, k)\nReturn fold of [0, x) × [0, y)\nfold [0, k]\nfold [0, i] x [0, j]\nfold [0, k)\nfold [0, i) x [0, j)\nf(x) += |x-a|\nf(x) += a\nf(x) += max(0, (a-x))\nf(x) += max(0, (x-a))\nClears the map, removing all elements.\nClears the set, removing all elements.\nright to left accumulated minimum\nleft to right accumulated minimum\nReturns true if the set contains a key.\nReturns true if the map contains a value for the key.\nOperate and consume range-value pairs in range.\nOperate and consume in range.\nReturn fold of range\nReturn fold of range\n0-indexed [i1, i2) x [j1, j2)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value corresponding to the key.\nGet a left neighboring range of <code>[key, key)</code> if the …\nGet a left neighboring range of <code>[key, key)</code> if the …\nReturns the range corresponding to the key.\nReturns the range-value pair corresponding to the key.\nGet a right neighboring range of <code>[key, key)</code> if the …\nGet a right neighboring range of <code>[key, key)</code> if the …\nInserts values into the specified range.\nInserts into the specified range.\nInsert values and operate old range-value pairs.\nInsert and operate old range.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nargmin_x f(x)\nmin f(x)\nMakes a new, empty <code>RangeMap</code>.\nMakes a new, empty <code>RangeSet</code>.\nCreate empty\nPop a left neighboring range of <code>[key, key)</code> if the …\nPop a left neighboring range of <code>[key, key)</code> if the …\nPop a right neighboring range of <code>[key, key)</code> if the …\nPop a right neighboring range of <code>[key, key)</code> if the …\nReturns the first index that satisfies a accumlative …\nReturns the first index that satisfies a accumlative …\nReturns the first index that satisfies a accumlative …\nReturns the first index that satisfies a accumlative …\nget k-th smallest value in range\nget k-th smallest value out of range\nthe number of val in range\nthe number of 0 in [0, k)\nthe number of 0 in [0, k)\nthe number of 1 in [0, k)\nthe number of 1 in [0, k)\nthe number of value less than val in range\nthe number of valrange in range\nRemove values contained in the range.\nRemove items contained in the range.\nReturns the last index that satisfies a accumlative …\nReturns the last index that satisfies a accumlative …\nReturns the last index that satisfies a accumlative …\nReturns the last index that satisfies a accumlative …\nindex of k-th val\nindex of k-th 0\nindex of k-th 0\nindex of k-th 1\nindex of k-th 1\nf’(x) := f(x-a)\nf’(x) := min f(y) (x-a &lt;= y &lt;= x-b)\nbuild transducer\nadd a, a+d, …, a+(k-1)d into [l, l + k)\nadd a, a+d, …, a+(k-1)d into [l, l + k)\nCreate valley\nmax-heap\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>cmp(key)</code>: <code>Ordering</code> between splaying and <code>key</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\na–b-vc\na–b-^c\na–c–b\nc–a–b\na–b–c\nReturn norm\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGraph represented by a list of edges.\nStatic Sparse Graph represented as Compressed Sparse Row.\n(p_x = f) | (p_y = g)\ncost is monge: cost(v1-1, v2) + cost(v1, v2-1) &gt;= cost(v1, …\nx1 &gt;= v1 &amp;&amp; x2 &lt; v2 (0 &lt; v1 &lt; nv1, 0 &lt; v2 &lt; nv2)\nx1 &lt; v1 &amp;&amp; x2 &gt;= v2 (0 &lt; v1 &lt; nv1, 0 &lt; v2 &lt; nv2)\nReturn a slice of adjacency vertices.\nReturn the number of edges.\nReturn the number of edges.\nf: |g, root, ord: [vertex, parent]| {}\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct graph from edges.\nConstruct graph from edges.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn (flow, cost).\nReturn (flow, cost).\ntarjan\nConstruct empty graph.\ntree center\ntree center\n(order, parents)\nReturn an iterator over graph vertices.\nReturn an iterator over graph vertices.\nReturn the number of vertices.\nReturn the number of vertices.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nstore with index ${\\lfloor\\frac{n}{i}\\rfloor \\mid …\na^x ≡ b (mod n)\nn! = a * p^e, c==1\nSum of Floor of Linear mod 2^64\nSum of Floor of Linear mod 2^64\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nbinary gcd\n[(hcn, #divisor)]\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLagrange interpolation with (i, f(i)) (0 &lt;= i &lt;= n)\nsum_i a_i exp(b_i x)\nconvert $\\sum_{i\\leq n} f(i)$ to $\\sum_{i\\leq n, i\\text{ …\nconvert $\\sum_{i\\leq n, i\\text{ is prime}} f(i)$ to $\\sum_…\n$$f(m) = \\sum_{n \\mid m}h(n)$$\n$$f(m) = \\sum_{n \\mid m}h(n)$$\n$$f(m) = \\sum_{n \\mid m}h(n)$$\n$$f(m) = \\sum_{n \\mid m}h(n)$$\n0 &lt; a &lt; p, gcd(a, p) == 1, p is prime &gt; 2\ng(d) = Sigma mu(d) * f(n/d)\nlist primes less than or equal to <code>max_n</code> by segmented sieve\nreturn: (y,z)\nreturn: (y,z)\nf(x) &lt;- f(x + a)\n$$g(m) = \\sum_{n \\mid m}f(n)$$\n$$g(m) = \\sum_{n \\mid m}f(n)$$\n$$g(m) = \\sum_{n \\mid m}f(n)$$\n$$g(m) = \\sum_{n \\mid m}f(n)$$\nTrait for operations of integer in binary representation.\nTrait for max/min bounds\nextended_gcd(a,b): ax + by = g = gcd(a,b)\nTrait for basic primitive integer operations.\nref: https://na-inet.jp/na/qd_ja.pdf\nWrapper type of arithmetic <code>saturating_*</code> operations.\nTrait for signed integer operations.\nTrait for unsigned integer operations.\nWrapper type of arithmetic <code>wrapping_*</code> operations.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ngcd\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nm\nm is prime, n = 2^32\nn^1 mod m\nn^1 mod m\nn^2 mod m\nn^2 mod m\nn^3 mod m\nn^3 mod m\n(-m)^{-1} mod n\n(-m)^{-1} mod n\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nn^{-1}x = (x + (xr mod n)m) / n\nn^{-1}x = (x + (xr mod n)m) / n\nThe <code>Read</code> trait allows for reading bytes from a source.\nA trait for objects which are byte-oriented sinks.\nCreates a “by reference” adaptor for this instance of …\nCreates a “by reference” adapter for this instance of …\nTransforms this <code>Read</code> instance to an <code>Iterator</code> over its …\nCreates an adapter which will chain this stream with …\nFlushes this output stream, ensuring that all …\nDetermines if this <code>Read</code>er has an efficient <code>read_vectored</code> …\nDetermines if this <code>Write</code>r has an efficient <code>write_vectored</code> …\nPrint expressions with a separator.\nPull some bytes from this source into the specified …\nPull some bytes from this source into the specified buffer.\nReads the exact number of bytes required to fill <code>cursor</code>.\nReads the exact number of bytes required to fill <code>buf</code>.\nReads all bytes until EOF in this source, placing them …\nReads all bytes until EOF in this source, appending them …\nLike <code>read</code>, except that it reads into a slice of buffers.\nscan and bind values with Scanner\nCreates an adapter which will read at most <code>limit</code> bytes …\nWrites a buffer into this writer, returning how many bytes …\nAttempts to write an entire buffer into this writer.\nAttempts to write multiple buffers into this writer.\nWrites a formatted string into this writer, returning any …\nLike <code>write</code>, except that it writes from a slice of buffers.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrait for a modifiable value associated with a type.\nLeft-close Right-open No Empty Segment\nTrait for spec of generating random value.\nType of value.\nimplement Ord by PartialOrd\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nmap <code>0..=25</code> to <code>&#39;A&#39;..=&#39;Z&#39;</code>\nmap <code>0..=25</code> to <code>&#39;a&#39;..=&#39;z&#39;</code>\nmap <code>0..=9</code> to <code>&#39;0&#39;..=&#39;9&#39;</code>\nmap <code>0..=25</code> to <code>&#39;A&#39;..=&#39;Z&#39;</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nmap (<code>&#39;A&#39;..=&#39;Z&#39;</code> or <code>&#39;a&#39;..=&#39;z&#39;</code>) to <code>0..=25</code>\nmap <code>&#39;a&#39;..=&#39;z&#39;</code> to <code>0..=25</code>\nmap <code>&#39;0&#39;..=&#39;9&#39;</code> to <code>0..=9</code>\nmap <code>&#39;A&#39;..=&#39;Z&#39;</code> to <code>0..=25</code>\nReturn a random value.\nReturn an iterator that generates random values.\nReturn an iterator that generates random values.\nscan and bind values with Scanner\nscan a value with Scanner\nGenerate Tree with Prüfer sequence\ndynamic programming on all-rooted trees\ndp[v]: result of v-rooted tree\nep[e]: result of e-subtree, if e &gt;= n then …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")