(function() {var implementors = {};
implementors["competitive"] = [{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeSumRangeAdd.html\" title=\"struct competitive::algebra::RangeSumRangeAdd\">RangeSumRangeAdd</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeSumRangeAdd"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeSumRangeLinear.html\" title=\"struct competitive::algebra::RangeSumRangeLinear\">RangeSumRangeLinear</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeSumRangeLinear"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeSumRangeUpdate.html\" title=\"struct competitive::algebra::RangeSumRangeUpdate\">RangeSumRangeUpdate</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeSumRangeUpdate"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeMaxRangeUpdate.html\" title=\"struct competitive::algebra::RangeMaxRangeUpdate\">RangeMaxRangeUpdate</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeMaxRangeUpdate"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeMinRangeUpdate.html\" title=\"struct competitive::algebra::RangeMinRangeUpdate\">RangeMinRangeUpdate</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeMinRangeUpdate"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.RangeMinRangeAdd.html\" title=\"struct competitive::algebra::RangeMinRangeAdd\">RangeMinRangeAdd</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::monoid_action::monoid_action_impls::RangeMinRangeAdd"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.MaxOperation.html\" title=\"struct competitive::algebra::MaxOperation\">MaxOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::max_operation_impl::MaxOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.MinOperation.html\" title=\"struct competitive::algebra::MinOperation\">MinOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::min_operation_impl::MinOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.FirstOperation.html\" title=\"struct competitive::algebra::FirstOperation\">FirstOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::first_operation_impl::FirstOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.LastOperation.html\" title=\"struct competitive::algebra::LastOperation\">LastOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::last_operation_impl::LastOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.AdditiveOperation.html\" title=\"struct competitive::algebra::AdditiveOperation\">AdditiveOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::additive_operation_impl::AdditiveOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.MultiplicativeOperation.html\" title=\"struct competitive::algebra::MultiplicativeOperation\">MultiplicativeOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::multiplicative_operation_impl::MultiplicativeOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.LinearOperation.html\" title=\"struct competitive::algebra::LinearOperation\">LinearOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::linear_operation_impl::LinearOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.BitAndOperation.html\" title=\"struct competitive::algebra::BitAndOperation\">BitAndOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::bitand_operation_impl::BitAndOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.BitOrOperation.html\" title=\"struct competitive::algebra::BitOrOperation\">BitOrOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::bitor_operation_impl::BitOrOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.BitXorOperation.html\" title=\"struct competitive::algebra::BitXorOperation\">BitXorOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::bitxor_operation_impl::BitXorOperation"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.CountingOperation.html\" title=\"struct competitive::algebra::CountingOperation\">CountingOperation</a>&lt;M&gt;","synthetic":true,"types":["competitive::algebra::operations::counting_operation_impl::CountingOperation"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.ReverseOperation.html\" title=\"struct competitive::algebra::ReverseOperation\">ReverseOperation</a>&lt;M&gt;","synthetic":true,"types":["competitive::algebra::operations::reverse_operation_impl::ReverseOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.Top2Operation.html\" title=\"struct competitive::algebra::Top2Operation\">Top2Operation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::top2_operation_impl::Top2Operation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.Bottom2Operation.html\" title=\"struct competitive::algebra::Bottom2Operation\">Bottom2Operation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::bottom2_operation_impl::Bottom2Operation"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/algebra/enum.PermutationOperation.html\" title=\"enum competitive::algebra::PermutationOperation\">PermutationOperation</a>","synthetic":true,"types":["competitive::algebra::operations::permutation_operation_impl::PermutationOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.FindMajorityOperation.html\" title=\"struct competitive::algebra::FindMajorityOperation\">FindMajorityOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::operations::find_majority_operation_impl::FindMajorityOperation"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algebra/struct.AddMulOperation.html\" title=\"struct competitive::algebra::AddMulOperation\">AddMulOperation</a>&lt;T&gt;","synthetic":true,"types":["competitive::algebra::ring::AddMulOperation"]},{"text":"impl&lt;G&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.BabyStepGiantStep.html\" title=\"struct competitive::algorithm::BabyStepGiantStep\">BabyStepGiantStep</a>&lt;G&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;G as <a class=\"trait\" href=\"competitive/algebra/trait.Magma.html\" title=\"trait competitive::algebra::Magma\">Magma</a>&gt;::<a class=\"associatedtype\" href=\"competitive/algebra/trait.Magma.html#associatedtype.T\" title=\"type competitive::algebra::Magma::T\">T</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::algorithm::baby_step_giant_step::BabyStepGiantStep"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.BitDp.html\" title=\"struct competitive::algorithm::BitDp\">BitDp</a>","synthetic":true,"types":["competitive::algorithm::bitdp::BitDp"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.Subsets.html\" title=\"struct competitive::algorithm::Subsets\">Subsets</a>","synthetic":true,"types":["competitive::algorithm::bitdp::Subsets"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.Combinations.html\" title=\"struct competitive::algorithm::Combinations\">Combinations</a>","synthetic":true,"types":["competitive::algorithm::bitdp::Combinations"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.IndependentSubSet.html\" title=\"struct competitive::algorithm::IndependentSubSet\">IndependentSubSet</a>&lt;M&gt;","synthetic":true,"types":["competitive::algorithm::chromatic_number::IndependentSubSet"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.ConvexHullTrick.html\" title=\"struct competitive::algorithm::ConvexHullTrick\">ConvexHullTrick</a>","synthetic":true,"types":["competitive::algorithm::convex_hull_trick::ConvexHullTrick"]},{"text":"impl&lt;S, F, G, L, R&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.PartisanGamer.html\" title=\"struct competitive::algorithm::PartisanGamer\">PartisanGamer</a>&lt;S, F, G, L, R&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::algorithm::partisan_game::PartisanGamer"]},{"text":"impl&lt;G&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.PartisanGameAnalyzer.html\" title=\"struct competitive::algorithm::PartisanGameAnalyzer\">PartisanGameAnalyzer</a>&lt;G&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;G: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::algorithm::partisan_game::PartisanGameAnalyzer"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.RhoPath.html\" title=\"struct competitive::algorithm::RhoPath\">RhoPath</a>&lt;T&gt;","synthetic":true,"types":["competitive::algorithm::rho_path::RhoPath"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.SlideMinimum.html\" title=\"struct competitive::algorithm::SlideMinimum\">SlideMinimum</a>&lt;'a&gt;","synthetic":true,"types":["competitive::algorithm::slide_minimum::SlideMinimum"]},{"text":"impl&lt;S&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.SqrtDecompositionBuckets.html\" title=\"struct competitive::algorithm::SqrtDecompositionBuckets\">SqrtDecompositionBuckets</a>&lt;S&gt;","synthetic":true,"types":["competitive::algorithm::sqrt_decomposition::SqrtDecompositionBuckets"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.XorBasis.html\" title=\"struct competitive::algorithm::XorBasis\">XorBasis</a>","synthetic":true,"types":["competitive::algorithm::xorbasis::XorBasis"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.SubsetTransform.html\" title=\"struct competitive::algorithm::SubsetTransform\">SubsetTransform</a>&lt;M&gt;","synthetic":true,"types":["competitive::algorithm::zeta_transform::SubsetTransform"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.SupersetTransform.html\" title=\"struct competitive::algorithm::SupersetTransform\">SupersetTransform</a>&lt;M&gt;","synthetic":true,"types":["competitive::algorithm::zeta_transform::SupersetTransform"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.DivisorTransform.html\" title=\"struct competitive::algorithm::DivisorTransform\">DivisorTransform</a>&lt;M&gt;","synthetic":true,"types":["competitive::algorithm::zeta_transform::DivisorTransform"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/algorithm/struct.MultipleTransform.html\" title=\"struct competitive::algorithm::MultipleTransform\">MultipleTransform</a>&lt;M&gt;","synthetic":true,"types":["competitive::algorithm::zeta_transform::MultipleTransform"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.KnapsackPloblemSmallWeight.html\" title=\"struct competitive::combinatorial_optimization::KnapsackPloblemSmallWeight\">KnapsackPloblemSmallWeight</a>","synthetic":true,"types":["competitive::combinatorial_optimization::knapsack_problem::KnapsackPloblemSmallWeight"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.KnapsackPloblemSmallValue.html\" title=\"struct competitive::combinatorial_optimization::KnapsackPloblemSmallValue\">KnapsackPloblemSmallValue</a>","synthetic":true,"types":["competitive::combinatorial_optimization::knapsack_problem::KnapsackPloblemSmallValue"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.ZeroOneKnapsackProblemSmallItems.html\" title=\"struct competitive::combinatorial_optimization::ZeroOneKnapsackProblemSmallItems\">ZeroOneKnapsackProblemSmallItems</a>","synthetic":true,"types":["competitive::combinatorial_optimization::knapsack_problem::ZeroOneKnapsackProblemSmallItems"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.ZeroOneKnapsackPloblemBranchAndBound.html\" title=\"struct competitive::combinatorial_optimization::ZeroOneKnapsackPloblemBranchAndBound\">ZeroOneKnapsackPloblemBranchAndBound</a>","synthetic":true,"types":["competitive::combinatorial_optimization::knapsack_problem::ZeroOneKnapsackPloblemBranchAndBound"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.LexicographicalSubsequence.html\" title=\"struct competitive::combinatorial_optimization::LexicographicalSubsequence\">LexicographicalSubsequence</a>","synthetic":true,"types":["competitive::combinatorial_optimization::lexicographical_subsequence::LexicographicalSubsequence"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/combinatorial_optimization/struct.LongestIncreasingSubsequence.html\" title=\"struct competitive::combinatorial_optimization::LongestIncreasingSubsequence\">LongestIncreasingSubsequence</a>&lt;T&gt;","synthetic":true,"types":["competitive::combinatorial_optimization::longest_increasing_subsequence::LongestIncreasingSubsequence"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.Accumulate.html\" title=\"struct competitive::data_structure::Accumulate\">Accumulate</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::accumulate::Accumulate"]},{"text":"impl&lt;M, A&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.Automatondp.html\" title=\"struct competitive::data_structure::Automatondp\">Automatondp</a>&lt;M, A&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::Automatondp"]},{"text":"impl&lt;X, Y&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.IntersectionAutomaton.html\" title=\"struct competitive::data_structure::IntersectionAutomaton\">IntersectionAutomaton</a>&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::IntersectionAutomaton"]},{"text":"impl&lt;X, Y&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.UnionAutomaton.html\" title=\"struct competitive::data_structure::UnionAutomaton\">UnionAutomaton</a>&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::UnionAutomaton"]},{"text":"impl&lt;X, Y&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.ProductAutomaton.html\" title=\"struct competitive::data_structure::ProductAutomaton\">ProductAutomaton</a>&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::ProductAutomaton"]},{"text":"impl&lt;A, S, F, G, H&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.FunctionalAutomaton.html\" title=\"struct competitive::data_structure::FunctionalAutomaton\">FunctionalAutomaton</a>&lt;A, S, F, G, H&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;H: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::FunctionalAutomaton"]},{"text":"impl&lt;A, S, F, G, H&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.MappingAutomaton.html\" title=\"struct competitive::data_structure::MappingAutomaton\">MappingAutomaton</a>&lt;A, S, F, G, H&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;H: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::MappingAutomaton"]},{"text":"impl&lt;A, S, B, F, G, H&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.AlphabetMappingAutomaton.html\" title=\"struct competitive::data_structure::AlphabetMappingAutomaton\">AlphabetMappingAutomaton</a>&lt;A, S, B, F, G, H&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;A: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;H: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::automaton::AlphabetMappingAutomaton"]},{"text":"impl&lt;'a, T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.LexicographicalAutomaton.html\" title=\"struct competitive::data_structure::LexicographicalAutomaton\">LexicographicalAutomaton</a>&lt;'a, T&gt;","synthetic":true,"types":["competitive::data_structure::automaton::LexicographicalAutomaton"]},{"text":"impl&lt;'a, T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.RevLexicographicalAutomaton.html\" title=\"struct competitive::data_structure::RevLexicographicalAutomaton\">RevLexicographicalAutomaton</a>&lt;'a, T&gt;","synthetic":true,"types":["competitive::data_structure::automaton::RevLexicographicalAutomaton"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.MonoidalAutomaton.html\" title=\"struct competitive::data_structure::MonoidalAutomaton\">MonoidalAutomaton</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::automaton::MonoidalAutomaton"]},{"text":"impl&lt;A&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.AlwaysAcceptingAutomaton.html\" title=\"struct competitive::data_structure::AlwaysAcceptingAutomaton\">AlwaysAcceptingAutomaton</a>&lt;A&gt;","synthetic":true,"types":["competitive::data_structure::automaton::AlwaysAcceptingAutomaton"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.BinaryIndexedTree.html\" title=\"struct competitive::data_structure::BinaryIndexedTree\">BinaryIndexedTree</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::binary_indexed_tree::BinaryIndexedTree"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.BinaryIndexedTree2D.html\" title=\"struct competitive::data_structure::BinaryIndexedTree2D\">BinaryIndexedTree2D</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::binary_indexed_tree_2d::BinaryIndexedTree2D"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.BitVector.html\" title=\"struct competitive::data_structure::BitVector\">BitVector</a>","synthetic":true,"types":["competitive::data_structure::bit_vector::BitVector"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.BitSet.html\" title=\"struct competitive::data_structure::BitSet\">BitSet</a>","synthetic":true,"types":["competitive::data_structure::bitset::BitSet"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.HashCounter.html\" title=\"struct competitive::data_structure::HashCounter\">HashCounter</a>&lt;T&gt;","synthetic":true,"types":["competitive::data_structure::counter::HashCounter"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.BTreeCounter.html\" title=\"struct competitive::data_structure::BTreeCounter\">BTreeCounter</a>&lt;T&gt;","synthetic":true,"types":["competitive::data_structure::counter::BTreeCounter"]},{"text":"impl&lt;S&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.DisjointSparseTable.html\" title=\"struct competitive::data_structure::DisjointSparseTable\">DisjointSparseTable</a>&lt;S&gt;","synthetic":true,"types":["competitive::data_structure::disjoint_sparse_table::DisjointSparseTable"]},{"text":"impl&lt;T, U, V&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.Static2DTree.html\" title=\"struct competitive::data_structure::Static2DTree\">Static2DTree</a>&lt;T, U, V&gt;","synthetic":true,"types":["competitive::data_structure::kdtree::Static2DTree"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.LazySegmentTree.html\" title=\"struct competitive::data_structure::LazySegmentTree\">LazySegmentTree</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::lazy_segment_tree::LazySegmentTree"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.LazySegmentTreeMap.html\" title=\"struct competitive::data_structure::LazySegmentTreeMap\">LazySegmentTreeMap</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::lazy_segment_tree_map::LazySegmentTreeMap"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.LineSet.html\" title=\"struct competitive::data_structure::LineSet\">LineSet</a>&lt;T&gt;","synthetic":true,"types":["competitive::data_structure::line_set::LineSet"]},{"text":"impl&lt;T, F&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.MergingUnionFind.html\" title=\"struct competitive::data_structure::MergingUnionFind\">MergingUnionFind</a>&lt;T, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::merging_union_find::MergingUnionFind"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.RangeArithmeticProgressionAdd.html\" title=\"struct competitive::data_structure::RangeArithmeticProgressionAdd\">RangeArithmeticProgressionAdd</a>","synthetic":true,"types":["competitive::data_structure::range_ap_add::RangeArithmeticProgressionAdd"]},{"text":"impl&lt;K, V&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.RangeMap.html\" title=\"struct competitive::data_structure::RangeMap\">RangeMap</a>&lt;K, V&gt;","synthetic":true,"types":["competitive::data_structure::range_map::RangeMap"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.RangeSet.html\" title=\"struct competitive::data_structure::RangeSet\">RangeSet</a>&lt;T&gt;","synthetic":true,"types":["competitive::data_structure::range_map::RangeSet"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.SegmentTree.html\" title=\"struct competitive::data_structure::SegmentTree\">SegmentTree</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::segment_tree::SegmentTree"]},{"text":"impl&lt;M, X, Y&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.SegmentTree2D.html\" title=\"struct competitive::data_structure::SegmentTree2D\">SegmentTree2D</a>&lt;M, X, Y&gt;","synthetic":true,"types":["competitive::data_structure::segment_tree_2d::SegmentTree2D"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.SegmentTreeMap.html\" title=\"struct competitive::data_structure::SegmentTreeMap\">SegmentTreeMap</a>&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as <a class=\"trait\" href=\"competitive/algebra/trait.Magma.html\" title=\"trait competitive::algebra::Magma\">Magma</a>&gt;::<a class=\"associatedtype\" href=\"competitive/algebra/trait.Magma.html#associatedtype.T\" title=\"type competitive::algebra::Magma::T\">T</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::data_structure::segment_tree_map::SegmentTreeMap"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.QueueAggregation.html\" title=\"struct competitive::data_structure::QueueAggregation\">QueueAggregation</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::sliding_winsow_aggregation::QueueAggregation"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.DequeAggregation.html\" title=\"struct competitive::data_structure::DequeAggregation\">DequeAggregation</a>&lt;M&gt;","synthetic":true,"types":["competitive::data_structure::sliding_winsow_aggregation::DequeAggregation"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.SlopeTrick.html\" title=\"struct competitive::data_structure::SlopeTrick\">SlopeTrick</a>","synthetic":true,"types":["competitive::data_structure::slope_trick::SlopeTrick"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.Trie.html\" title=\"struct competitive::data_structure::Trie\">Trie</a>","synthetic":true,"types":["competitive::data_structure::trie::Trie"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.UnionFind.html\" title=\"struct competitive::data_structure::UnionFind\">UnionFind</a>","synthetic":true,"types":["competitive::data_structure::union_find::UnionFind"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.WaveletMatrix.html\" title=\"struct competitive::data_structure::WaveletMatrix\">WaveletMatrix</a>","synthetic":true,"types":["competitive::data_structure::wavelet_matrix::WaveletMatrix"]},{"text":"impl&lt;G&gt; Freeze for <a class=\"struct\" href=\"competitive/data_structure/struct.WeightedUnionFind.html\" title=\"struct competitive::data_structure::WeightedUnionFind\">WeightedUnionFind</a>&lt;G&gt;","synthetic":true,"types":["competitive::data_structure::weighted_union_find::WeightedUnionFind"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/geometry/struct.Approx.html\" title=\"struct competitive::geometry::Approx\">Approx</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::geometry::approx::Approx"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/geometry/enum.Ccw.html\" title=\"enum competitive::geometry::Ccw\">Ccw</a>","synthetic":true,"types":["competitive::geometry::ccw::Ccw"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/geometry/struct.Circle.html\" title=\"struct competitive::geometry::Circle\">Circle</a>","synthetic":true,"types":["competitive::geometry::circle::Circle"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/geometry/struct.Line.html\" title=\"struct competitive::geometry::Line\">Line</a>","synthetic":true,"types":["competitive::geometry::line::Line"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/geometry/struct.LineSegment.html\" title=\"struct competitive::geometry::LineSegment\">LineSegment</a>","synthetic":true,"types":["competitive::geometry::line::LineSegment"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.AdjacencyListGraph.html\" title=\"struct competitive::graph::AdjacencyListGraph\">AdjacencyListGraph</a>","synthetic":true,"types":["competitive::graph::adjacency_list::AdjacencyListGraph"]},{"text":"impl&lt;U, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.AdjacencyListGraphScanner.html\" title=\"struct competitive::graph::AdjacencyListGraphScanner\">AdjacencyListGraphScanner</a>&lt;U, T&gt;","synthetic":true,"types":["competitive::graph::adjacency_list::AdjacencyListGraphScanner"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.BipartiteMatching.html\" title=\"struct competitive::graph::BipartiteMatching\">BipartiteMatching</a>","synthetic":true,"types":["competitive::graph::bipartite_matching::BipartiteMatching"]},{"text":"impl&lt;Fa&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.UsizeGraph.html\" title=\"struct competitive::graph::UsizeGraph\">UsizeGraph</a>&lt;Fa&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Fa: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::closure::UsizeGraph"]},{"text":"impl&lt;V, Fv, Fa&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.ClosureGraph.html\" title=\"struct competitive::graph::ClosureGraph\">ClosureGraph</a>&lt;V, Fv, Fa&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Fa: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fv: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::closure::ClosureGraph"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.EdgeListGraph.html\" title=\"struct competitive::graph::EdgeListGraph\">EdgeListGraph</a>","synthetic":true,"types":["competitive::graph::edge_list::EdgeListGraph"]},{"text":"impl&lt;U, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.EdgeListGraphScanner.html\" title=\"struct competitive::graph::EdgeListGraphScanner\">EdgeListGraphScanner</a>&lt;U, T&gt;","synthetic":true,"types":["competitive::graph::edge_list::EdgeListGraphScanner"]},{"text":"impl&lt;V&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.VIndex.html\" title=\"struct competitive::graph::VIndex\">VIndex</a>&lt;V&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;V: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::VIndex"]},{"text":"impl&lt;V, E&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.VIndexWithEIndex.html\" title=\"struct competitive::graph::VIndexWithEIndex\">VIndexWithEIndex</a>&lt;V, E&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::VIndexWithEIndex"]},{"text":"impl&lt;V, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.VIndexWithValue.html\" title=\"struct competitive::graph::VIndexWithValue\">VIndexWithValue</a>&lt;V, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::VIndexWithValue"]},{"text":"impl&lt;V, E, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.VIndexWithEIndexValue.html\" title=\"struct competitive::graph::VIndexWithEIndexValue\">VIndexWithEIndexValue</a>&lt;V, E, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::VIndexWithEIndexValue"]},{"text":"impl&lt;'g, 'a, G, M, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.AdjacencyViewIterFromEindex.html\" title=\"struct competitive::graph::AdjacencyViewIterFromEindex\">AdjacencyViewIterFromEindex</a>&lt;'g, 'a, G, M, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;G as <a class=\"trait\" href=\"competitive/graph/trait.AdjacenciesWithEindex.html\" title=\"trait competitive::graph::AdjacenciesWithEindex\">AdjacenciesWithEindex</a>&lt;'g&gt;&gt;::<a class=\"associatedtype\" href=\"competitive/graph/trait.AdjacenciesWithEindex.html#associatedtype.AIter\" title=\"type competitive::graph::AdjacenciesWithEindex::AIter\">AIter</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::AdjacencyViewIterFromEindex"]},{"text":"impl&lt;'g, 'a, G, M, T, U&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.AdjacencyViewIterFromValue.html\" title=\"struct competitive::graph::AdjacencyViewIterFromValue\">AdjacencyViewIterFromValue</a>&lt;'g, 'a, G, M, T, U&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;G as <a class=\"trait\" href=\"competitive/graph/trait.AdjacenciesWithValue.html\" title=\"trait competitive::graph::AdjacenciesWithValue\">AdjacenciesWithValue</a>&lt;'g, T&gt;&gt;::<a class=\"associatedtype\" href=\"competitive/graph/trait.AdjacenciesWithValue.html#associatedtype.AIter\" title=\"type competitive::graph::AdjacenciesWithValue::AIter\">AIter</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::graph::graph_base::AdjacencyViewIterFromValue"]},{"text":"impl&lt;A&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.GridGraph.html\" title=\"struct competitive::graph::GridGraph\">GridGraph</a>&lt;A&gt;","synthetic":true,"types":["competitive::graph::grid::GridGraph"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.LowLink.html\" title=\"struct competitive::graph::LowLink\">LowLink</a>&lt;'a&gt;","synthetic":true,"types":["competitive::graph::low_link::LowLink"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.DinicBuilder.html\" title=\"struct competitive::graph::DinicBuilder\">DinicBuilder</a>","synthetic":true,"types":["competitive::graph::maximum_flow::DinicBuilder"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.Dinic.html\" title=\"struct competitive::graph::Dinic\">Dinic</a>&lt;'a&gt;","synthetic":true,"types":["competitive::graph::maximum_flow::Dinic"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.PrimalDualBuilder.html\" title=\"struct competitive::graph::PrimalDualBuilder\">PrimalDualBuilder</a>","synthetic":true,"types":["competitive::graph::minimum_cost_flow::PrimalDualBuilder"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.PrimalDual.html\" title=\"struct competitive::graph::PrimalDual\">PrimalDual</a>&lt;'a&gt;","synthetic":true,"types":["competitive::graph::minimum_cost_flow::PrimalDual"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.ProjectSelectionProblem.html\" title=\"struct competitive::graph::ProjectSelectionProblem\">ProjectSelectionProblem</a>","synthetic":true,"types":["competitive::graph::project_selection_problem::ProjectSelectionProblem"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.StandardSp.html\" title=\"struct competitive::graph::StandardSp\">StandardSp</a>&lt;M&gt;","synthetic":true,"types":["competitive::graph::shortest_path::StandardSp"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.OptionSp.html\" title=\"struct competitive::graph::OptionSp\">OptionSp</a>&lt;M&gt;","synthetic":true,"types":["competitive::graph::shortest_path::OptionSp"]},{"text":"impl&lt;M, S&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.PathFoldingSp.html\" title=\"struct competitive::graph::PathFoldingSp\">PathFoldingSp</a>&lt;M, S&gt;","synthetic":true,"types":["competitive::graph::shortest_path::PathFoldingSp"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/graph/enum.DirectedEdge.html\" title=\"enum competitive::graph::DirectedEdge\">DirectedEdge</a>","synthetic":true,"types":["competitive::graph::sparse_graph::DirectedEdge"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/graph/enum.UndirectedEdge.html\" title=\"enum competitive::graph::UndirectedEdge\">UndirectedEdge</a>","synthetic":true,"types":["competitive::graph::sparse_graph::UndirectedEdge"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/graph/enum.BidirectionalEdge.html\" title=\"enum competitive::graph::BidirectionalEdge\">BidirectionalEdge</a>","synthetic":true,"types":["competitive::graph::sparse_graph::BidirectionalEdge"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.Adjacency.html\" title=\"struct competitive::graph::Adjacency\">Adjacency</a>","synthetic":true,"types":["competitive::graph::sparse_graph::Adjacency"]},{"text":"impl&lt;D&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.SparseGraph.html\" title=\"struct competitive::graph::SparseGraph\">SparseGraph</a>&lt;D&gt;","synthetic":true,"types":["competitive::graph::sparse_graph::SparseGraph"]},{"text":"impl&lt;T, D&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.SparseGraphBuilder.html\" title=\"struct competitive::graph::SparseGraphBuilder\">SparseGraphBuilder</a>&lt;T, D&gt;","synthetic":true,"types":["competitive::graph::sparse_graph::SparseGraphBuilder"]},{"text":"impl&lt;U, T, D&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.SparseGraphScanner.html\" title=\"struct competitive::graph::SparseGraphScanner\">SparseGraphScanner</a>&lt;U, T, D&gt;","synthetic":true,"types":["competitive::graph::sparse_graph::SparseGraphScanner"]},{"text":"impl&lt;U, T&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.TreeGraphScanner.html\" title=\"struct competitive::graph::TreeGraphScanner\">TreeGraphScanner</a>&lt;U, T&gt;","synthetic":true,"types":["competitive::graph::sparse_graph::TreeGraphScanner"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/graph/struct.StronglyConnectedComponent.html\" title=\"struct competitive::graph::StronglyConnectedComponent\">StronglyConnectedComponent</a>&lt;'a&gt;","synthetic":true,"types":["competitive::graph::strongly_connected_component::StronglyConnectedComponent"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/graph/struct.TwoSatisfiability.html\" title=\"struct competitive::graph::TwoSatisfiability\">TwoSatisfiability</a>","synthetic":true,"types":["competitive::graph::two_satisfiability::TwoSatisfiability"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/math/prime_list/struct.PrimeList.html\" title=\"struct competitive::math::prime_list::PrimeList\">PrimeList</a>","synthetic":true,"types":["competitive::math::prime::prime_list::PrimeList"]},{"text":"impl&lt;'p&gt; Freeze for <a class=\"struct\" href=\"competitive/math/prime_list/struct.PrimeListTrialDivision.html\" title=\"struct competitive::math::prime_list::PrimeListTrialDivision\">PrimeListTrialDivision</a>&lt;'p&gt;","synthetic":true,"types":["competitive::math::prime::prime_list::PrimeListTrialDivision"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.MemorizedFactorial.html\" title=\"struct competitive::math::MemorizedFactorial\">MemorizedFactorial</a>&lt;M&gt;","synthetic":true,"types":["competitive::math::factorial::MemorizedFactorial"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.SmallModMemorizedFactorial.html\" title=\"struct competitive::math::SmallModMemorizedFactorial\">SmallModMemorizedFactorial</a>&lt;M&gt;","synthetic":true,"types":["competitive::math::factorial::SmallModMemorizedFactorial"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.PowPrec.html\" title=\"struct competitive::math::PowPrec\">PowPrec</a>&lt;M&gt;","synthetic":true,"types":["competitive::math::factorial::PowPrec"]},{"text":"impl&lt;T, C&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.FormalPowerSeries.html\" title=\"struct competitive::math::FormalPowerSeries\">FormalPowerSeries</a>&lt;T, C&gt;","synthetic":true,"types":["competitive::math::formal_power_series::FormalPowerSeries"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.Matrix.html\" title=\"struct competitive::math::Matrix\">Matrix</a>&lt;T&gt;","synthetic":true,"types":["competitive::math::matrix::Matrix"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.Convolve.html\" title=\"struct competitive::math::Convolve\">Convolve</a>&lt;M&gt;","synthetic":true,"types":["competitive::math::number_theoretic_transform::Convolve"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/math/struct.Polynomial.html\" title=\"struct competitive::math::Polynomial\">Polynomial</a>&lt;T&gt;","synthetic":true,"types":["competitive::math::polynomial::Polynomial"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/math/struct.PrimeTable.html\" title=\"struct competitive::math::PrimeTable\">PrimeTable</a>","synthetic":true,"types":["competitive::math::prime::PrimeTable"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/math/struct.EulerPhiTable.html\" title=\"struct competitive::math::EulerPhiTable\">EulerPhiTable</a>","synthetic":true,"types":["competitive::math::prime::EulerPhiTable"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/math/struct.Mersenne61.html\" title=\"struct competitive::math::Mersenne61\">Mersenne61</a>","synthetic":true,"types":["competitive::math::special_modulo::Mersenne61"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/math/struct.Mersenne127.html\" title=\"struct competitive::math::Mersenne127\">Mersenne127</a>","synthetic":true,"types":["competitive::math::special_modulo::Mersenne127"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/mint_basic/enum.Modulo998244353.html\" title=\"enum competitive::num::mint_basic::Modulo998244353\">Modulo998244353</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::Modulo998244353"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/mint_basic/enum.Modulo1000000007.html\" title=\"enum competitive::num::mint_basic::Modulo1000000007\">Modulo1000000007</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::Modulo1000000007"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/mint_basic/enum.Modulo1000000009.html\" title=\"enum competitive::num::mint_basic::Modulo1000000009\">Modulo1000000009</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::Modulo1000000009"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/mint_basic/enum.DynModuloU32.html\" title=\"enum competitive::num::mint_basic::DynModuloU32\">DynModuloU32</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::DynModuloU32"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/mint_basic/enum.DynModuloU64.html\" title=\"enum competitive::num::mint_basic::DynModuloU64\">DynModuloU64</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::DynModuloU64"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/num/mint_basic/struct.Modulo2.html\" title=\"struct competitive::num::mint_basic::Modulo2\">Modulo2</a>","synthetic":true,"types":["competitive::num::mint::mint_basic::Modulo2"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/montgomery/enum.Modulo998244353.html\" title=\"enum competitive::num::montgomery::Modulo998244353\">Modulo998244353</a>","synthetic":true,"types":["competitive::num::mint::montgomery::Modulo998244353"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/montgomery/enum.Modulo2113929217.html\" title=\"enum competitive::num::montgomery::Modulo2113929217\">Modulo2113929217</a>","synthetic":true,"types":["competitive::num::mint::montgomery::Modulo2113929217"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/montgomery/enum.Modulo1811939329.html\" title=\"enum competitive::num::montgomery::Modulo1811939329\">Modulo1811939329</a>","synthetic":true,"types":["competitive::num::mint::montgomery::Modulo1811939329"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/num/montgomery/enum.Modulo2013265921.html\" title=\"enum competitive::num::montgomery::Modulo2013265921\">Modulo2013265921</a>","synthetic":true,"types":["competitive::num::mint::montgomery::Modulo2013265921"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.BarrettReduction.html\" title=\"struct competitive::num::BarrettReduction\">BarrettReduction</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::barrett_reduction::BarrettReduction"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.Complex.html\" title=\"struct competitive::num::Complex\">Complex</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::complex::Complex"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/num/struct.DoubleDouble.html\" title=\"struct competitive::num::DoubleDouble\">DoubleDouble</a>","synthetic":true,"types":["competitive::num::double_double::DoubleDouble"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/num/struct.Float32.html\" title=\"struct competitive::num::Float32\">Float32</a>","synthetic":true,"types":["competitive::num::float::Float32"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/num/struct.Float64.html\" title=\"struct competitive::num::Float64\">Float64</a>","synthetic":true,"types":["competitive::num::float::Float64"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.ExtendedGcd.html\" title=\"struct competitive::num::ExtendedGcd\">ExtendedGcd</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;T as <a class=\"trait\" href=\"competitive/num/trait.Unsigned.html\" title=\"trait competitive::num::Unsigned\">Unsigned</a>&gt;::<a class=\"associatedtype\" href=\"competitive/num/trait.Unsigned.html#associatedtype.Signed\" title=\"type competitive::num::Unsigned::Signed\">Signed</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::integer::ExtendedGcd"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.Saturating.html\" title=\"struct competitive::num::Saturating\">Saturating</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::integer::Saturating"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.Wrapping.html\" title=\"struct competitive::num::Wrapping\">Wrapping</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::integer::Wrapping"]},{"text":"impl&lt;M&gt; Freeze for <a class=\"struct\" href=\"competitive/num/struct.MInt.html\" title=\"struct competitive::num::MInt\">MInt</a>&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as <a class=\"trait\" href=\"competitive/num/trait.MIntBase.html\" title=\"trait competitive::num::MIntBase\">MIntBase</a>&gt;::<a class=\"associatedtype\" href=\"competitive/num/trait.MIntBase.html#associatedtype.Inner\" title=\"type competitive::num::MIntBase::Inner\">Inner</a>: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::num::mint::mint_base::MInt"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/num/struct.QuadDouble.html\" title=\"struct competitive::num::QuadDouble\">QuadDouble</a>","synthetic":true,"types":["competitive::num::quad_double::QuadDouble"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/prelude/enum.Chars.html\" title=\"enum competitive::prelude::Chars\">Chars</a>","synthetic":true,"types":["competitive::tools::scanner::Chars"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/prelude/struct.Scanner.html\" title=\"struct competitive::prelude::Scanner\">Scanner</a>&lt;'a&gt;","synthetic":true,"types":["competitive::tools::scanner::Scanner"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/prelude/enum.Usize1.html\" title=\"enum competitive::prelude::Usize1\">Usize1</a>","synthetic":true,"types":["competitive::tools::scanner::Usize1"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/string/struct.KnuthMorrisPratt.html\" title=\"struct competitive::string::KnuthMorrisPratt\">KnuthMorrisPratt</a>&lt;T&gt;","synthetic":true,"types":["competitive::string::knuth_morris_pratt::KnuthMorrisPratt"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/string/struct.RollingHash.html\" title=\"struct competitive::string::RollingHash\">RollingHash</a>","synthetic":true,"types":["competitive::string::rolling_hash::RollingHash"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/string/struct.MultipleRollingHash.html\" title=\"struct competitive::string::MultipleRollingHash\">MultipleRollingHash</a>","synthetic":true,"types":["competitive::string::rolling_hash::MultipleRollingHash"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/string/struct.SuffixArray.html\" title=\"struct competitive::string::SuffixArray\">SuffixArray</a>&lt;T&gt;","synthetic":true,"types":["competitive::string::suffix_array::SuffixArray"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/string/struct.Zarray.html\" title=\"struct competitive::string::Zarray\">Zarray</a>","synthetic":true,"types":["competitive::string::z_algorithm::Zarray"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.SimuratedAnnealing.html\" title=\"struct competitive::tools::SimuratedAnnealing\">SimuratedAnnealing</a>","synthetic":true,"types":["competitive::tools::heuristics::SimuratedAnnealing"]},{"text":"impl&lt;T, U&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.PartialIgnoredOrd.html\" title=\"struct competitive::tools::PartialIgnoredOrd\">PartialIgnoredOrd</a>&lt;T, U&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tools::partial_ignored_ord::PartialIgnoredOrd"]},{"text":"impl&lt;'r, T, R&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.RandIter.html\" title=\"struct competitive::tools::RandIter\">RandIter</a>&lt;'r, T, R&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;R: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tools::random::random_generator::RandIter"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.NotEmptySegment.html\" title=\"struct competitive::tools::NotEmptySegment\">NotEmptySegment</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tools::random::random_generator::NotEmptySegment"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.Xorshift.html\" title=\"struct competitive::tools::Xorshift\">Xorshift</a>","synthetic":true,"types":["competitive::tools::random::Xorshift"]},{"text":"impl&lt;'a, 'b, T&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.ScannerIter.html\" title=\"struct competitive::tools::ScannerIter\">ScannerIter</a>&lt;'a, 'b, T&gt;","synthetic":true,"types":["competitive::tools::scanner::ScannerIter"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.CharWithBase.html\" title=\"struct competitive::tools::CharWithBase\">CharWithBase</a>","synthetic":true,"types":["competitive::tools::scanner::CharWithBase"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.CharsWithBase.html\" title=\"struct competitive::tools::CharsWithBase\">CharsWithBase</a>","synthetic":true,"types":["competitive::tools::scanner::CharsWithBase"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.ByteWithBase.html\" title=\"struct competitive::tools::ByteWithBase\">ByteWithBase</a>","synthetic":true,"types":["competitive::tools::scanner::ByteWithBase"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/tools/enum.Bytes.html\" title=\"enum competitive::tools::Bytes\">Bytes</a>","synthetic":true,"types":["competitive::tools::scanner::Bytes"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tools/struct.BytesWithBase.html\" title=\"struct competitive::tools::BytesWithBase\">BytesWithBase</a>","synthetic":true,"types":["competitive::tools::scanner::BytesWithBase"]},{"text":"impl&lt;T, B&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.Collect.html\" title=\"struct competitive::tools::Collect\">Collect</a>&lt;T, B&gt;","synthetic":true,"types":["competitive::tools::scanner::Collect"]},{"text":"impl&lt;T, B&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.SizedCollect.html\" title=\"struct competitive::tools::SizedCollect\">SizedCollect</a>&lt;T, B&gt;","synthetic":true,"types":["competitive::tools::scanner::SizedCollect"]},{"text":"impl&lt;T, P&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.Splitted.html\" title=\"struct competitive::tools::Splitted\">Splitted</a>&lt;T, P&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;P: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tools::scanner::Splitted"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tools/struct.TotalOrd.html\" title=\"struct competitive::tools::TotalOrd\">TotalOrd</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tools::totalord::TotalOrd"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.EulerTourForEdge.html\" title=\"struct competitive::tree::EulerTourForEdge\">EulerTourForEdge</a>&lt;'a&gt;","synthetic":true,"types":["competitive::tree::euler_tour::EulerTourForEdge"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.EulerTourForVertex.html\" title=\"struct competitive::tree::EulerTourForVertex\">EulerTourForVertex</a>&lt;'a&gt;","synthetic":true,"types":["competitive::tree::euler_tour::EulerTourForVertex"]},{"text":"impl&lt;'a&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.EulerTourForRichVertex.html\" title=\"struct competitive::tree::EulerTourForRichVertex\">EulerTourForRichVertex</a>&lt;'a&gt;","synthetic":true,"types":["competitive::tree::euler_tour::EulerTourForRichVertex"]},{"text":"impl&lt;'a, D&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.LowestCommonAncestor.html\" title=\"struct competitive::tree::LowestCommonAncestor\">LowestCommonAncestor</a>&lt;'a, D&gt;","synthetic":true,"types":["competitive::tree::euler_tour::LowestCommonAncestor"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/tree/enum.LcaMonoidDefaultId.html\" title=\"enum competitive::tree::LcaMonoidDefaultId\">LcaMonoidDefaultId</a>","synthetic":true,"types":["competitive::tree::euler_tour::LcaMonoidDefaultId"]},{"text":"impl&lt;D&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.LcaMonoid.html\" title=\"struct competitive::tree::LcaMonoid\">LcaMonoid</a>&lt;D&gt;","synthetic":true,"types":["competitive::tree::euler_tour::LcaMonoid"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.PruferSequence.html\" title=\"struct competitive::tree::PruferSequence\">PruferSequence</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tree::generator::PruferSequence"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.PathTree.html\" title=\"struct competitive::tree::PathTree\">PathTree</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tree::generator::PathTree"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.StarTree.html\" title=\"struct competitive::tree::StarTree\">StarTree</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tree::generator::StarTree"]},{"text":"impl&lt;T&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.MixedTree.html\" title=\"struct competitive::tree::MixedTree\">MixedTree</a>&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tree::generator::MixedTree"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tree/struct.HeavyLightDecomposition.html\" title=\"struct competitive::tree::HeavyLightDecomposition\">HeavyLightDecomposition</a>","synthetic":true,"types":["competitive::tree::heavy_light_decomposition::HeavyLightDecomposition"]},{"text":"impl&lt;'a, M, F&gt; Freeze for <a class=\"struct\" href=\"competitive/tree/struct.ReRooting.html\" title=\"struct competitive::tree::ReRooting\">ReRooting</a>&lt;'a, M, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: Freeze,&nbsp;</span>","synthetic":true,"types":["competitive::tree::rerooting::ReRooting"]},{"text":"impl Freeze for <a class=\"enum\" href=\"competitive/tree/enum.TreeCenter.html\" title=\"enum competitive::tree::TreeCenter\">TreeCenter</a>","synthetic":true,"types":["competitive::tree::tree_center::TreeCenter"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tree/struct.TreeHasher.html\" title=\"struct competitive::tree::TreeHasher\">TreeHasher</a>","synthetic":true,"types":["competitive::tree::tree_hash::TreeHasher"]},{"text":"impl Freeze for <a class=\"struct\" href=\"competitive/tree/struct.TreeRec.html\" title=\"struct competitive::tree::TreeRec\">TreeRec</a>","synthetic":true,"types":["competitive::tree::tree_rec::TreeRec"]}];
if (window.register_implementors) {window.register_implementors(implementors);} else {window.pending_implementors = implementors;}})()