(function() {var implementors = {};
implementors["competitive"] = [{"text":"impl&lt;T:&nbsp;Clone + Ord + MinimumBounded&gt; Clone for MaxOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Ord + MaximumBounded&gt; Clone for MinOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq&gt; Clone for FirstOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq&gt; Clone for LastOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + Zero + Add&lt;Output = T&gt;&gt; Clone for AdditiveOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + One + Mul&lt;Output = T&gt;&gt; Clone for MultiplicativeOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + PartialEq + Zero + Add&lt;Output = T&gt; + One + Mul&lt;Output = T&gt;&gt; Clone for LinearOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + PartialEq + BitAndIdentity&gt; Clone for BitAndOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + PartialEq + BitOrIdentity&gt; Clone for BitOrOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Copy + PartialEq + BitXorIdentity&gt; Clone for BitXorOperation&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq, F:&nbsp;Clone + Fn(&amp;T, &amp;T) -&gt; T&gt; Clone for MonoidalOperation&lt;T, F&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq, F:&nbsp;Clone + Fn(&amp;T, &amp;T) -&gt; T, G:&nbsp;Clone + Fn(&amp;T) -&gt; T&gt; Clone for GroupOperation&lt;T, F, G&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq, F:&nbsp;Clone + Fn(&amp;T, &amp;T) -&gt; T&gt; Clone for AssocoativeOperator&lt;T, F&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + PartialEq, F:&nbsp;Clone + Fn(&amp;T, &amp;T) -&gt; T&gt; Clone for AbsorbedAssocoativeOperator&lt;T, F&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M1:&nbsp;Clone, M2:&nbsp;Clone&gt; Clone for CartesianOperation&lt;M1, M2&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone&gt; Clone for CountingOperation&lt;M&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone&gt; Clone for ReverseOperation&lt;M&gt;","synthetic":false,"types":[]},{"text":"impl Clone for CHTLine","synthetic":false,"types":[]},{"text":"impl Clone for ConvexHullTrick","synthetic":false,"types":[]},{"text":"impl Clone for ZeroOneKnapsackProblemSmallItems","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Ord&gt; Clone for LongestIncreasingSubsequence&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;A:&nbsp;Clone&gt; Clone for AlwaysAcceptingAutomaton&lt;A&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid&gt; Clone for BinaryIndexedTree&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid&gt; Clone for BinaryIndexedTree2D&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl Clone for BitSet","synthetic":false,"types":[]},{"text":"impl&lt;S:&nbsp;Clone + SemiGroup&gt; Clone for DisjointSparseTable&lt;S&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid, E:&nbsp;Clone + Monoid, F:&nbsp;Clone + Fn(&amp;M::T, &amp;E::T) -&gt; M::T&gt; Clone for LazySegmentTree&lt;M, E, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;E::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid&gt; Clone for SegmentTree&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid&gt; Clone for QueueAggregation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Monoid&gt; Clone for DequeAggregation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl Clone for UnionFind","synthetic":false,"types":[]},{"text":"impl&lt;G:&nbsp;Clone + Group&gt; Clone for WeightedUnionFind&lt;G&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;G::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl Clone for Circle","synthetic":false,"types":[]},{"text":"impl Clone for Line","synthetic":false,"types":[]},{"text":"impl Clone for LineSegment","synthetic":false,"types":[]},{"text":"impl Clone for Real","synthetic":false,"types":[]},{"text":"impl Clone for CCW","synthetic":false,"types":[]},{"text":"impl Clone for Adjacency","synthetic":false,"types":[]},{"text":"impl Clone for AdjacencyListGraph","synthetic":false,"types":[]},{"text":"impl Clone for EdgeListGraph","synthetic":false,"types":[]},{"text":"impl Clone for GridGraph","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for Adjacency4&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for Adjacency8&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl Clone for DinicBuilder","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for Dinic&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl Clone for PrimalDualBuilder","synthetic":false,"types":[]},{"text":"impl Clone for DirectedEdge","synthetic":false,"types":[]},{"text":"impl Clone for UndirectedEdge","synthetic":false,"types":[]},{"text":"impl Clone for BidirectionalEdge","synthetic":false,"types":[]},{"text":"impl Clone for Adjacency","synthetic":false,"types":[]},{"text":"impl&lt;D:&nbsp;Clone&gt; Clone for SparseGraph&lt;D&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for StronglyConnectedComponent&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl Clone for TwoSatisfiability","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Modulus&gt; Clone for MemorizedFactorial&lt;M&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Clone + Modulus&gt; Clone for SmallModMemorizedFactorial&lt;M&gt;","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone&gt; Clone for Matrix&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl Clone for BabyStepGiantStep","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone&gt; Clone for Polynomial&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl Clone for PrimeTable","synthetic":false,"types":[]},{"text":"impl Clone for EulerPhiTable","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone&gt; Clone for Complex&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl&lt;M:&nbsp;Modulus&gt; Clone for MInt&lt;M&gt;","synthetic":false,"types":[]},{"text":"impl Clone for QuadDouble","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Eq&gt; Clone for KnuthMorrisPratt&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl Clone for RollingHash","synthetic":false,"types":[]},{"text":"impl Clone for MultipleRollingHash","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone&gt; Clone for SuffixArray&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl Clone for Zarray","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + Eq + Hash&gt; Clone for Counter&lt;T&gt;","synthetic":false,"types":[]},{"text":"impl Clone for Xorshift","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for Scanner&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl Clone for Usize1","synthetic":false,"types":[]},{"text":"impl Clone for Chars","synthetic":false,"types":[]},{"text":"impl Clone for CharsWithBase","synthetic":false,"types":[]},{"text":"impl&lt;T:&nbsp;Clone + IterScan, B:&nbsp;Clone + FromIterator&lt;&lt;T as IterScan&gt;::Output&gt;&gt; Clone for Collect&lt;T, B&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for EulerTourForEdge&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for EulerTourForVertex&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for EulerTourForRichVertex&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl&lt;'a&gt; Clone for LowestCommonAncestor&lt;'a&gt;","synthetic":false,"types":[]},{"text":"impl Clone for LCAMonoid","synthetic":false,"types":[]},{"text":"impl&lt;'a, M:&nbsp;Clone + Monoid, F:&nbsp;Clone + Fn(&amp;M::T, usize, Option&lt;usize&gt;) -&gt; M::T&gt; Clone for ReRooting&lt;'a, M, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,<br>&nbsp;&nbsp;&nbsp;&nbsp;M::T: Clone,&nbsp;</span>","synthetic":false,"types":[]},{"text":"impl Clone for TreeRec","synthetic":false,"types":[]}];
if (window.register_implementors) {window.register_implementors(implementors);} else {window.pending_implementors = implementors;}})()