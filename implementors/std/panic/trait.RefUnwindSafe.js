(function() {var implementors = {};
implementors["competitive"] = [{"text":"impl&lt;T&gt; RefUnwindSafe for MaxOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for MinOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for FirstOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for LastOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for AdditiveOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for MultiplicativeOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for LinearOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for BitAndOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for BitOrOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for BitXorOperation&lt;T&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T, F&gt; RefUnwindSafe for MonoidalOperation&lt;T, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;T, F, G&gt; RefUnwindSafe for GroupOperation&lt;T, F, G&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;G: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;T, F&gt; RefUnwindSafe for AssocoativeOperator&lt;T, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;T, F&gt; RefUnwindSafe for AbsorbedAssocoativeOperator&lt;T, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M1, M2&gt; RefUnwindSafe for CartesianOperation&lt;M1, M2&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M1: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;M2: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for CountingOperation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for ReverseOperation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for CHTLine","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for ConvexHullTrick","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for SlideMinimum&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for SubsetTransform&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for SupersetTransform&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for DivisorTransform&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for MultipleTransform&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for KnapsackPloblemSmallWeight","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for KnapsackPloblemSmallValue","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for ZeroOneKnapsackProblemSmallItems","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for ZeroOneKnapsackPloblemBranchAndBound","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for LongestIncreasingSubsequence&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;X, Y&gt; RefUnwindSafe for IntersectionAutomaton&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;X, Y&gt; RefUnwindSafe for UnionAutomaton&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;X, Y&gt; RefUnwindSafe for ProductAutomaton&lt;X, Y&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;X: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;Y: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;'a, T&gt; RefUnwindSafe for LessThanAutomaton&lt;'a, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;'a, T&gt; RefUnwindSafe for GreaterThanAutomaton&lt;'a, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;'a, T&gt; RefUnwindSafe for ContainAutomaton&lt;'a, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;'a, T&gt; RefUnwindSafe for ContainCounterAutomaton&lt;'a, T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;A&gt; RefUnwindSafe for AlwaysAcceptingAutomaton&lt;A&gt;","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for BinaryIndexedTree&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for BinaryIndexedTree2D&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for BitVector","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for BitSet","synthetic":true,"types":[]},{"text":"impl&lt;S&gt; RefUnwindSafe for DisjointSparseTable&lt;S&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;S as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;T, U, V&gt; RefUnwindSafe for Static2DTree&lt;T, U, V&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;U: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;V: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M, E, F&gt; RefUnwindSafe for LazySegmentTree&lt;M, E, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;E: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;E as Magma&gt;::T: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for SegmentTree&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for DequeAggregation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for QueueAggregation&lt;M&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Trie","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for UnionFind","synthetic":true,"types":[]},{"text":"impl&lt;G&gt; RefUnwindSafe for WeightedUnionFind&lt;G&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;G: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;G as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;T, F&gt; !RefUnwindSafe for MergingUnionFind&lt;T, F&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for WaveletMatrix","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Circle","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Line","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for LineSegment","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Real","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for CCW","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Adjacent","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Graph","synthetic":true,"types":[]},{"text":"impl&lt;U, T&gt; RefUnwindSafe for GraphScanner&lt;U, T&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for GraphRec","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for GraphEidCache&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for GridGraph","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for Adjacent4&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for Adjacent8&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for SparseGraph","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for LowLink&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for RevEdge","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for FordFulkerson","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Dinic","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for RevCEdge","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for PrimalDual","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for StronglyConnectedComponent&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for TwoSatisfiability","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for MemorizedFactorial&lt;M&gt;","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for SmallModMemorizedFactorial&lt;M&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for Matrix&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for NumberTheoreticTransform&lt;M&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for BabyStepGiantStep","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for Polynomial&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for PrimeTable","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for EulerPhiTable","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for Complex&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl&lt;M&gt; RefUnwindSafe for MInt&lt;M&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for QuadDouble","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Modulo1000000007","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Modulo1000000009","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Modulo998244353","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for DynModulo","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for KnuthMorrisPratt&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for MultipleRollingHash","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for RollingHash","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for SuffixArray&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Zarray","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for Counter&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for SimuratedAnnealing","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Xorshift","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for Scanner&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl&lt;T&gt; RefUnwindSafe for TotalOrd&lt;T&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Usize1","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for Chars","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for CharsWithBase","synthetic":true,"types":[]},{"text":"impl&lt;T, B&gt; RefUnwindSafe for Collect&lt;T, B&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for EulerTourForEdge","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for EulerTourForVertex","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for EulerTourForRichVertex","synthetic":true,"types":[]},{"text":"impl&lt;'a&gt; RefUnwindSafe for LowestCommonAncestor&lt;'a&gt;","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for LCAMonoid","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for HeavyLightDecomposition","synthetic":true,"types":[]},{"text":"impl&lt;M, F&gt; RefUnwindSafe for ReRooting&lt;M, F&gt; <span class=\"where fmt-newline\">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;M: RefUnwindSafe,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;M as Magma&gt;::T: RefUnwindSafe,&nbsp;</span>","synthetic":true,"types":[]},{"text":"impl RefUnwindSafe for TreeRec","synthetic":true,"types":[]}];
if (window.register_implementors) {window.register_implementors(implementors);} else {window.pending_implementors = implementors;}})()